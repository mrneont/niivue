<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: session-bus.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: session-bus.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { v4 as uuidv4 } from "uuid";
import { webSocket } from "rxjs/webSocket";

/**
 * @class SessionUser
 * @type SessionUser
 * @description SessionUser specifies display name, user id and user key
 * @param {string} displayName
 * @param {string} userId
 * @param {string} userKey Used to protect user properties
 * @param {Map} userProperties
 */
export function SessionUser(
  displayName = undefined,
  userId = undefined,
  userKey = undefined,
  userProperties = undefined
) {
  this.id = userId || uuidv4();
  this.displayName = displayName || `user-${this.id}`;
  this.key = userKey || uuidv4();
  this.properties = userProperties || new Map();
}

/**
 * Checks if local storage is available
 * @param {string} type type of local storage requested
 * @returns {boolean}
 */
function storageAvailable(type) {
  let storage;
  try {
    storage = window[type];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (e) {
    return (
      e instanceof DOMException &amp;&amp;
      // everything except Firefox
      (e.code === 22 ||
        // Firefox
        e.code === 1014 ||
        // test name field too, because code might not be present
        // everything except Firefox
        e.name === "QuotaExceededError" ||
        // Firefox
        e.name === "NS_ERROR_DOM_QUOTA_REACHED") &amp;&amp;
      // acknowledge QuotaExceededError only if there's something already stored
      storage &amp;&amp;
      storage.length !== 0
    );
  }
}

/**
 * @class SessionBus
 * @type SessionBus
 * @description SessionBus is for synchronizing both remote and local instances
 * @constructor
 * @param {string} name
 * @param {SessionUser} user
 * @param {function} onMessageCallback  call back for new messages
 * @param {string} serverURL
 */
export function SessionBus(
  name,
  user,
  onMessageCallback,
  serverURL = "",
  sessionKey = ""
) {
  this.userList = [];
  this.user = user || new SessionUser("anonymous");

  this.onMessageCallBack = onMessageCallback;

  this.isConnectedToServer = false;
  this.isController = false;

  this.sessionScene = {};
  this.sessionKey = sessionKey ? sessionKey : uuidv4();

  this.sessionName = name;
  this.sessionSceneName = `session-${name}-scene`;

  if (serverURL) {
    // remote
    this.serverConnection$ = null;
    this.connectToServer(serverURL, name);
    this.subscribeToServer();
    this.isConnectedToServer = true;
    this.serverConnection$.next({
      op: SessionBus.MESSAGE.CREATE,
      key: this.sessionKey,
    });
  } else {
    // local
    if (!storageAvailable("localStorage")) {
      throw "Local storage unavailable";
    }

    this.userQueueName = `user-${this.user.id}-q`;
    this.userListName = `${name}-user-list`;

    // add our user to the list
    this.userList = JSON.parse(localStorage.getItem(this.userListName) || "[]");
    this.userList.push(this.user);
    localStorage.setItem(this.userListName, JSON.stringify(this.userList));

    // create our message queue
    localStorage.setItem(this.userQueueName, JSON.stringify([]));

    window.addEventListener(
      "storage",
      this.localStorageEventListener.bind(this)
    );
  }
}

SessionBus.prototype.sendSessionMessage = function (message) {
  message.from = this.userId;
  if (this.isConnectedToServer) {
    this.serverConnection$.next({
      ...message,
      key: this.sessionKey,
      userKey: this.userKey,
    });
  } else {
    this.sendLocalMessage(message);
  }
};

// Remote
// not included in public docs
// Internal function to connect to web socket server
SessionBus.prototype.connectToServer = function (serverURL, sessionName) {
  const url = new URL(serverURL);
  url.pathname = "websockets";
  url.search = "?session=" + sessionName;
  this.serverConnection$ = webSocket(url.href);
  console.log(url.href);
};

// Internal function called after a connection with the server has been made
SessionBus.prototype.subscribeToServer = function () {
  this.serverConnection$.subscribe({
    next: (msg) => {
      this.onMessageCallBack(msg);
    }, // Called whenever there is a message from the server.
    error: (err) => console.log(err), // Called if at any point WebSocket API signals some kind of error.
    complete: () => console.log("complete"), // Called when connection is closed (for whatever reason).
  });
};

SessionBus.prototype.sendLocalMessage = function (message) {
  // add the message for each client
  for (const user of this.userList) {
    if (user.id === this.userId) {
      continue;
    }
    let userQueueName = `user-${user.id}-q`;
    let userQueueText = localStorage.getItem(userQueueName);
    let userQueue = userQueueText ? JSON.parse(userQueueText) : [];
    userQueue.push(message);
    localStorage.setItem(userQueueName, JSON.stringify(userQueue));
  }
};

SessionBus.prototype.localStorageEventListener = function (e) {
  // is this message for us?
  switch (e.key) {
    case this.userListName:
      {
        this.userList = JSON.parse(e.newValue);
        // compare new and old values
        let newUsers = JSON.parse(e.newValue).filter(
          (u) =>
            !JSON.parse(e.oldValue)
              .map((o) => o.id)
              .includes(u.id)
        );
        for (const newUser of newUsers) {
          this.onMessageCallBack({
            op: "user joined",
            user: newUser,
          });
        }
      }
      break;
    case this.userQueueName:
      {
        let messages = JSON.parse(e.newValue);
        for (const message of messages) {
          if (this.onMessageCallBack) {
            this.onMessageCallBack(message);
          }
        }
        // reset our message queue
        localStorage.setItem(this.userQueueName, []);
      }
      break;
  }
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="NVController.html">NVController</a></li><li><a href="NVDocument.html">NVDocument</a></li><li><a href="NVImage.html">NVImage</a></li><li><a href="global.html#NVImageFromUrlOptions">NVImageFromUrlOptions</a></li><li><a href="NVMesh.html">NVMesh</a></li><li><a href="global.html#NVMeshFromUrlOptions">NVMeshFromUrlOptions</a></li><li><a href="NVMessage.html">NVMessage</a></li><li><a href="NVMessageSet4DVolumeIndexData.html">NVMessageSet4DVolumeIndexData</a></li><li><a href="NVMesssageUpdateData.html">NVMesssageUpdateData</a></li><li><a href="NVUtilities.html">NVUtilities</a></li><li><a href="Niivue.html">Niivue</a></li><li><a href="NiivueObject3D.html">NiivueObject3D</a></li><li><a href="SessionBus.html">SessionBus</a></li><li><a href="SessionUser.html">SessionUser</a></li><li><a href="Shader.html">Shader</a></li></ul><h3>Global</h3><ul><li><a href="global.html#DRAG_MODE">DRAG_MODE</a></li><li><a href="global.html#NVIMAGE_TYPE">NVIMAGE_TYPE</a></li><li><a href="global.html#NVMESSAGE">NVMESSAGE</a></li><li><a href="global.html#SLICE_TYPE">SLICE_TYPE</a></li><li><a href="global.html#getExtents">getExtents</a></li><li><a href="global.html#storageAvailable">storageAvailable</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Wed May 10 2023 18:22:37 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
